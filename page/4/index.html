<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Lao Yuan&#39;s Personal Website">
<meta property="og:url" content="http://gityuanye.cn/page/4/index.html">
<meta property="og:site_name" content="Lao Yuan&#39;s Personal Website">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lao Yuan&#39;s Personal Website">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gityuanye.cn/page/4/"/>





  <title>Lao Yuan's Personal Website</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lao Yuan's Personal Website</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">LaoYuan</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2016/01/15/MySQL 数据库锁定机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/15/MySQL 数据库锁定机制/" itemprop="url">MySQL 数据库锁定机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-15T20:15:00+08:00">
                2016-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>MySQL 锁定机制简介</li>
</ol>
<p>​ 各存储引擎使用三种类型锁定机制</p>
<p>行级锁定（row-level）<br>表级锁定（table-level）<br>页级锁定（page-leve） ： 页级锁定介于行级锁定与表级锁定之间。</p>
<ol start="2">
<li>MySQL数据库中 表级锁定主要是 MyISAM、Memory、CSV 等一些非事务性存储引擎，使用行级锁定主要是 InnoDB 存储引擎和 NDB Cluster 存储引擎，页级锁定主要是BerkeleyDB存储引擎</li>
</ol>
<p>MyISAM 表级锁定主要分为两种类型<br>读锁定</p>
<p>，一个新客户端在申请获取读锁定资源的时候，需要满足两个条件：</p>
<p>请求锁定的资源当前没有被写锁定<br>写锁定等待队列 （Pending write-lock queue）中没有更高优先级的写锁定在等待<br>（只影响写操作）<br>写锁定</p>
<p>（影响读操作，同时也影响写操作）</p>
<ol start="4">
<li>MySQL中主要分4中队列来维护这两种锁定：两个存放当前正在锁定的读和写锁定信息，另外两个存放等待中的读写锁定西信息，如下：</li>
</ol>
<p>Current read-lock queue ( lock-&gt;read)<br>Pending read-lock queue (lock-&gt;read_wait)<br>Current write-lock queue (lock-&gt;write)<br>Pending write-lock queue (lock-&gt;write_wait)<br>InnoDB 的行级锁定分为四种类型<br>共享锁 （有叫做：读锁）<br>允许一个事务去读一行，阻止其他事务获得相同数据的排它锁。<br>排他锁 （有叫做：写锁）<br>允许获得排它锁的事务更新数据，阻止其他事务<br>意向共享锁<br>意向排他锁</p>
<ol start="6">
<li>InnoDB 间隙锁</li>
</ol>
<p>​ InnoDB 的锁定是通过在指向数据记录的第一个索引键之前和最后一个索引键之后的空域空间标记锁定信息实现的。这种锁定方式被称为 “NEXT-KEY locking”（间隙锁）</p>
<p>​ 间隙锁弱点：锁定一个范围之后，即使某些不存在的键值也会被无辜锁定，造成锁定的时候无法插入键值锁定内的任何数据。</p>
<p>​ 通过索引实现锁定的方式存在其他几个较大的性能隐患：</p>
<p>当 Query 无法利用索引的时候，InnoDB 会放弃使用 行级锁定 而改用 表级锁定 ，造成并发性能降低；<br>当 Query 使用的索引并不包含所有过滤条件时，数据检索使用到的索引键中的数据可能有部分不属于 Query 的结果集行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键。<br>当 Query 在使用索引定位数据的时候，如果使用的索引键一样但访问的数据行不同 （索引只是过滤条件的一部分）， 他们一样会被锁定。<br>MyISAM 表锁优化建议<br>缩短锁定时间<br>尽量减少大的复杂 Query，将复杂 Query 拆分成几个小的 Query 执行。<br>尽可能地建立足够高效的索引，让数据检索更迅速。<br>尽量让MyISAM 存储引擎的表只存放必要的信息，控制字段类型。<br>利用合适的机会优化 MyISAM 表数据文件。<br>分离能并行的操作<br>MyISAM 并非只能完全的串行化，MyISAM 存储引擎还有一个特性 Concurrent Insert（并发插入）的特性。<br>MyISAM 存储引擎有一个控制是否打开 Concurrent insert 功能的参数选项： concurrent_insert 可以设置为 0/1/2：具体如下：<br>concurrent_insert = 2，无论 MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都允许在数据文件尾部进行Concurrent Insert。<br>concurrent_insert = 1，MyISAM 存储引擎表数据文件中间不存在空闲空间的时候，可以从文件尾部进行 Concurrent Insert。<br>concurrent_insert = 0， 无论 MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都不允许 Concurrent Insert。（读锁时，不允许插入）<br>合理利用读写优先级<br>表级锁定 默认情况下写优先级大于读，如果读操作多的时候，可以设置读优先级高，可设置参数 low_priority_updates = 1。</p>
<ol start="8">
<li>InnoDB 行锁优化建议</li>
</ol>
<p>尽可能让所有的数据检索都通过索引来完成，从而避免 InnoDB 因为无法通过索引键加锁而升级为表级锁定<br>合理设计索引，让 InnoDB 在索引键上加锁的时候尽可能准确，尽可能地缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。<br>尽可能减少基于范围的数据检索过滤条件，避免因间隙锁带来的负面影响而锁定了不该锁定的记录。<br>尽量控制事务大小，减少锁定的资源量和锁定的时间长度。<br>在业务环境允许的情况下，尽量使用较低级别的事务隔离，减少 MySQL 因为实现事务隔离级别所带来的附加成本。</p>
<ol start="9">
<li>系统锁定争用情况查询</li>
</ol>
<p>​ MySQL 内部有两组专用的状态变量记录系统内部资源争用情况。</p>
<p>表级锁定的争用状态变量<br>​ mysql&gt; show status like ‘table%’;</p>
<p>Table_locks_immediate：产生表级锁定的次数；<br>Table_locks_waited：出现表级锁定争用而发生等待的次数<br>​ Table_locks_immediate 值大于 Table_locks_waited 5000 是比较合适的，在大就需要分析问题所在。</p>
<p>​ 两个状态值都是从系统启动后开始记录，每出现一次加1，如果这里 Table_locks_waited 状态值比较高，说明表级锁定争用严重，需进一步分析。</p>
<p>InnoDB 行级锁定状态变量记录<br>​ sql&gt; show status like ‘innodb_row_lock%’;</p>
<p>Innodb_row_lock_current_waites：当前正在等待锁定的数量；<br>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；<br>Innodb_row_lock_time_avg：每次等待所花平均时间；<br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；<br>Innodb_row_lock_waits：从系统启动到现在总等待次数。<br>​ 5个状态，比较重要的是 Innodb_row_lock_time_avg（等待平均时长），Innodb_row_lock_waits（等待总次数）及 Innodb_row_lock_time（等待总时长）</p>
<ol start="10">
<li>InnoDB 除了提供以上5个系统状态变量外，还提供了更为丰富的即时状态信息，实现方法如下：</li>
</ol>
<p>创建 InnoDB Monitor 表来打开 InnoDB的 monitor 功能<br>mysql &gt; create table innodb_monitor(a int) engine=innodb;<br>然后执行 ”show innodb status” 查看详细信息<br>​ 为什么创建 innodb_monitor 表？</p>
<p>​ 创建该表就是告诉InnoDB 我们要开始监控他的详细信息，然后InnoDB就会将比较详细的事务级锁定信息记录到MySQL的 error log 中，以便后面做进一步分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2016/01/10/几种Javascript语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/10/几种Javascript语法/" itemprop="url">几种Javascript语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-10T11:15:00+08:00">
                2016-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该书的作者是Douglas Crockford，他是目前世界上最精通Javascript的人之一，也是Json格式的创造者。</p>
<p>他认为Javascript有很多糟粕。因为1995年Brendan Eich设计这种语言的时候，只用了三个月，很多语言特性没有经过深思熟虑，就推向了市场。结果等到人们意识到这些问题的时候，已经有100万程序员在使用它了，不可能再大幅修改语言本身了。所以，Douglas Crockford决定，他要告诉大家，Javascript中哪些部分是精粹，哪些部分是糟粕和鸡肋。</p>
<p>这个想法非常好，但是我不得不说，这本书写得不够好，不适合新手阅读。原因如下：1）Douglas Crockford叙述得不清晰，更像与同行讨论问题，而不是由浅入深地讲解问题。这本书的重点不是解释，所以读完后，我觉得Javascript好像变得更复杂了。2）他固执地使用铁路图（railroad diagram）解释每一条语句。全世界似乎只有他一个人使用这种比Javascript更难看懂的图。3）该书基本上是一本简化的Javascript语法手册，缺乏足够的新内容。4）该书举例过少，而且在最难的函数和对象部分，使用的例子都是环环相套、层层递进的例子，导致阅读起来很吃力。</p>
<p>该书最有价值的内容不是正文，反而是附录。在附录B中，Douglas Crockford列出了12种应该避免使用的Javascript语法，我觉得非常值得推广。</p>
<p>==============================</p>
<p><strong>1. ==</strong></p>
<p>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。</p>
<p>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：</p>
<p>　　false == ‘false’</p>
<p>　　false == undefined</p>
<p>　　false == null</p>
<p>　　null == undefined</p>
<p>　　0 == ‘’</p>
<p>前三个是false，后两个是true。</p>
<p><strong>2. with</strong></p>
<p>with的本意是减少键盘输入。比如</p>
<p>　　obj.a = obj.b;</p>
<p>　　obj.c = obj.d;</p>
<p>可以简写成</p>
<p>　　with(obj) {<br>　　　　a = b;<br>　　　　c = d;<br>　　}</p>
<p>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p>
<p><strong>3. eval</strong></p>
<p>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>
<p>eval能够做到的事情，不用它也能做到。比如</p>
<p>　　eval(“myValue = myObject.” + myKey + “;”);</p>
<p>可以直接写成</p>
<p>　　myValue = myObject[myKey];</p>
<p>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器<a href="http://www.json.org/json_parse.js" target="_blank" rel="noopener">json_parse.js</a>运行。</p>
<p><strong>4. continue</strong></p>
<p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>
<p><strong>5. switch 贯穿</strong></p>
<p>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如</p>
<p>　　switch(n) {<br>　　　　case 1:<br>　　　　case 2:<br>　　　　　　break;<br>　　}</p>
<p>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。</p>
<p>　　switch(n) {<br>　　　　case 1:<br>　　　　　　break;<br>　　　　case 2:<br>　　　　　　break;<br>　　}</p>
<p><strong>6. 单行的块结构</strong></p>
<p>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如</p>
<p>　　if (ok) t = true;</p>
<p>甚至写成</p>
<p>　　if (ok)<br>　　　　t = true;</p>
<p>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>
<p>　　if (ok){<br>　　　　t = true;<br>　　}</p>
<p><strong>7. ++和–</strong></p>
<p>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>
<p><strong>8. 位运算符</strong></p>
<p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。</p>
<p>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p>
<p><strong>9. function语句</strong></p>
<p>在Javascript中定义一个函数，有两种写法：</p>
<p>　　function foo() { }</p>
<p>和</p>
<p>　　var foo = function () { }</p>
<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>
<p><strong>10. 基本数据类型的包装对象</strong></p>
<p>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：</p>
<p>　　new String(“Hello World”);</p>
<p>　　new Number(2000);</p>
<p>　　new Boolean(false);</p>
<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>
<p>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</p>
<p><strong>11. new语句</strong></p>
<p>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。</p>
<p>类是这样定义的：</p>
<p>　　var Cat = function (name) {<br>　　　　this.name = name;<br>　　　　this.saying = ‘meow’ ;<br>　　}</p>
<p>然后，再生成一个对象</p>
<p>　　var myCat = new Cat(‘mimi’);</p>
<p>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>
<p>Douglas Crockford给出了一个函数：</p>
<p>　　Object.beget = function (o) {<br>　　　　var F = function (o) {};<br>　　　　F.prototype = o ;<br>　　　　return new F;<br>　　};</p>
<p>创建对象时就利用这个函数，对原型对象进行操作：</p>
<p>　　var Cat = {<br>　　　　name:’’,<br>　　　　saying:’meow’<br>　　};</p>
<p>　　var myCat = Object.beget(Cat);</p>
<p>对象生成后，可以自行对相关属性进行赋值：</p>
<p>　　myCat.name = ‘mimi’;</p>
<p><strong>12. void</strong></p>
<p>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。</p>
<p>　　void 0; // undefined</p>
<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/12/13/h5+css3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/13/h5+css3/" itemprop="url">h5+css3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-13T09:15:00+08:00">
                2015-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>html+html5+css+css3</p>
<p>1.怪异模式和标准模式(box-sizing)</p>
<p>首先，两种模式可以利用box-sizing属性进行自行选择：</p>
<p>　　标准模式：box-sizing:<strong>content-box;</strong></p>
<p>　　怪异模式：box-sizing:<strong>border-box;</strong></p>
<p><strong>两种模式的区别：</strong></p>
<p>　　<strong>标准模式会被设置的padding撑开，而怪异模式则相当于将盒子的大小固定好，再将内容装入盒子。盒子的大小并不会被padding所撑开。</strong></p>
<p>例：</p>
<p>　　 .box{<br> box-sizing:border-box; //没有添加时，按照标准模式计算， 添加时按照怪异模式解析<br> width:200px;<br> height:200px;<br> border:2px solid black;<br> padding:50px;<br> margin:50px;<br> }</p>
<p>　　 标准模式：盒子总宽度/高度 = <strong>内容区宽度 /高度+padding+border + margin</strong>。</p>
<p> 盒子总宽度/高度 = <strong>width/height + margin。</strong></p>
<p>2.关于sessionstorage和localstorage</p>
<p><strong>1、web Storage</strong></p>
<p>web Storage 是HTML 5引入的一个重要的功能，在前端开发的过程中会经常用到，它可以在客户端本地存储数据，类似cookie，但其功能却比cookie强大的多。cookie的大小只有4Kb左右（浏览器不同，大小也不同），而web Storage的大小有5MB。其API提供的方法有以下几种：</p>
<p> setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>
<p> getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。</p>
<p> removeItem (key) —— 删除单个数据，根据键值移除对应的信息。</p>
<p> clear () —— 删除所有的数据</p>
<p> key (index) —— 获取某个索引的key</p>
<p><strong>2、localStorage</strong></p>
<p> localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。</p>
<p> localStorage 相对sessionStorage简单一点，需要注意的地方不是很多。</p>
<p> <strong>3、sessionStorage</strong></p>
<p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。</p>
<p> <1> 页面刷新不会消除数据</1></p>
<p> <2>只有在当前页面打开的链接，才可以访sessionStorage的数据；</2></p>
<p> <3>使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据</3></p>
<ul>
<li><strong>sessionStorage 、localStorage 和 cookie 之间的区别</strong><br>共同点：都是保存在浏览器端，且同源的。</li>
<li>区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</li>
<li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>
<li>作用域不同，sessionStorage<strong>不在</strong>不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</li>
</ul>
<p>缓存处理</p>
<p>dns 缓存</p>
<p>当你需要多次浏览一个网站的时候,需要多次解析这个网站的dns,这个时候本地就会产生dns缓存,当每次请求时候先确认你的缓存有没有过期,没有过期则先加载缓存中的数据</p>
<p>cdn 缓存</p>
<p>访问一个网站服务器 的时候,采取就近原则,即寻找最近的节点来访问,减少跨域,跨区请求的次数</p>
<p>浏览器缓存</p>
<p>浏览器会保存你访问过的网页的静态文件信息,再次访问优先读取缓存,如果缓存过期或者被清除则请求服务器</p>
<p>服务器缓存</p>
<p>指的是将需要频繁访问的网络内容存放在离用户较近、访问速度更快的系统中，以提高内容访问速度的一种技术。缓存服务器就是存放频繁访问内容的服务器。</p>
<p>图片预处理技术</p>
<p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，<br>如果前者小于后者，优先加载。<br>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。<br>如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。<br>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。<br>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展<br>示一致。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/11/30/session和cookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/30/session和cookie/" itemprop="url">session和cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-30T08:15:00+08:00">
                2015-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>session和cookie</p>
<p>1.设置cookie</p>
<p>Setcookie(名,值,过期时间,有效路径,有效域名)</p>
<p> 说明:</p>
<p>1) 名称: cookie名称, 为获取cookie值作准备</p>
<p>2) 值: cookie的值, 注意cookie值的类型. 只能是字符串</p>
<ol>
<li><p>字符串:</p>
</li>
<li><p>数组形式:</p>
<p>a) 设置形式：setcookie(‘c1[k1]’,值)</p>
<p>b) 读取形式：$_COOKIE [‘c1’][‘k1’]</p>
</li>
</ol>
<p>2.读取cookie</p>
<p> 通过超全局数组$_COOKIE获取</p>
<p>3.删除COOKIE的方法</p>
<p>1) 将时间过期; Setcookie(‘名’,值,time()-1);</p>
<p>2) 将时间过期; Setcookie(‘名’,值,time()-999999);</p>
<p>3) Setcookie(‘名’);</p>
<p>4) Setcookie(‘名’,’’);</p>
<p>2.session</p>
<ol>
<li><p>开启SESSION会话功能 session_start();</p>
</li>
<li><p>获取当前的SESSION的ID值 Session_id();</p>
</li>
<li><p>设置session的值 $_SESSION[‘名称’] = 值; //值的类型没有限制</p>
</li>
<li><p>读取SESSION数据</p>
</li>
<li><p>删除session Unset($_SESSION[‘username’])</p>
</li>
<li><p>销毁session_destroy();</p>
</li>
</ol>
<p>session的php.ini配置选项</p>
<p>　　php.ini文件和Session有关的几个常用配置选项：</p>
<p>　　session.auto_start = 0 ; 在请求启动时初始化session</p>
<p>　　session.cache_expire = 180 ; 设置缓存中的会话文档在 n 分钟后过时</p>
<p>　　session.cookie_lifetime = 0 ; 设置按秒记的cookie的保存时间，相当于设置Session的过期时间，为0时表示直到浏览器被重启</p>
<p>　　session.auto_start=1，这样就无需每次使用session之前都要调用session_start()不建议使用.但启用该选项也有一些限制，如果确实启用了 session.auto_start，则不能将对象放入会话中，因为类定义必须在启动会话之前加载以在会话中重建对象。</p>
<p>　　session.cookie_path = / ; cookie的有效路径</p>
<p>　　session.cookie_domain = ; cookie的有效域</p>
<p>　　session.name = PHPSESSID; 用在cookie里的session的名字</p>
<p>　　session.save_handler = files ; 用于保存/取回数据的控制方式</p>
<p>　　session.save_path = /tmp ; 在 save_handler 设为文件时传给控制器的参数， 这是数据文件将保存的路径.</p>
<p>　　session.use_cookies = 1 ; 是否使用cookies</p>
<p>　　session.setMaxInactiveInterval(30 * 60);//设置单位为秒，设置为-1永不过期</p>
<p>如何设置一个30分钟过期的Session?</p>
<p> 使用memcache, redis等, okey, 这种答案是一种正确答案</p>
<ol>
<li><p>设置Cookie过期时间30分钟, 并设置Session的lifetime也为30分钟.</p>
</li>
<li><p>自己为每一个Session值增加Time stamp.</p>
</li>
<li><p>每次访问之前, 判断时间戳.</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/11/06/http协议小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/06/http协议小记/" itemprop="url">http协议小记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-06T18:15:00+08:00">
                2015-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ol>
<li>http协议概述</li>
</ol>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）</p>
<ol>
<li><p>HTTP是一个客户端和服务器端请求和应答的标准</p>
</li>
<li><p>http协议特点</p>
</li>
</ol>
<p>a) <strong>简单,</strong>快速,只需要URL,传值的方法.</p>
<p>b) <strong>灵活</strong>.</p>
<p> i. header(‘content-type:text/html;charset=utf-8’);</p>
<p> ii. header(‘content-type:image/jpeg’);</p>
<p><strong>c)</strong> 无连接, (服务器与客户端的连接总是要断开的)</p>
<p>d) 无状态. http协议没有记忆功能. 页面与页面之间没有关系.</p>
<p>请求:</p>
<h5 id="1-HTTP请求的构成"><a href="#1-HTTP请求的构成" class="headerlink" title="1) HTTP请求的构成,"></a>1) HTTP请求的构成,</h5><p>请求的构成: 请求行, 请求头, 空白行, 请求体</p>
<h5 id="2-请求行的格式，"><a href="#2-请求行的格式，" class="headerlink" title="2) 请求行的格式，"></a>2) 请求行的格式，</h5><p>格式: 请求的方法 空格 URI信息 空格 协议的版本</p>
<h5 id="3-请求头格式"><a href="#3-请求头格式" class="headerlink" title="3) 请求头格式,"></a>3) 请求头格式,</h5><p>格式: key:空格value //属性: 空格 值</p>
<p><strong>4) 请求体格式</strong></p>
<p>get:无数据(get的参数在请求行中显示) post:携带数据信息</p>
<p>响应:</p>
<h5 id="1-http响应的构成"><a href="#1-http响应的构成" class="headerlink" title="1) http响应的构成"></a>1) http响应的构成</h5><p>响应行 响应头 空白行 响应体</p>
<h5 id="2-状态行的格式"><a href="#2-状态行的格式" class="headerlink" title="2) 状态行的格式"></a>2) 状态行的格式</h5><p>响应行: 也称为状态行,消息行</p>
<p>格式: HTTP版本 空格 状态码 空格状态文本</p>
<h5 id="3-常见的状态码"><a href="#3-常见的状态码" class="headerlink" title="3) 常见的状态码:"></a>3) 常见的状态码:</h5><p>l 200 //响应成功.</p>
<p>l 301 //域名的永久重定向</p>
<p>l 302 //域名的临时重定向</p>
<p>l 304 //本地加载资源</p>
<p>l 403 //没有访问权限</p>
<p>| 404 //访问的页面不存在</p>
<p>500 //指的是服务器内部的错误, 543,5XX</p>
<p>php中发送请求的函数curl扩展函数</p>
<p>curl发送请求主要分四步:</p>
<p>1) $curl = curl_init(url) 初始化请求的页面</p>
<p>2) curl_setopt($curl,参数,值);配置请求参数</p>
<p>3)result = curl _ exec ( $link ) 执行请求发送并接收返回的结果</p>
<p>4)curl_close ($link)关闭请求</p>
<p>常用几个参数:</p>
<p>CURLOPT_HTTPHEADER：请求头，以数组形式设定，类似如下：</p>
<p>array(‘host:url’,’Accept:text/html’,’Accept-Language:zh-cn,zh’)</p>
<p>CURLOPT_HEADER：true/false, 设置返回的数据中是否带响应头信息</p>
<p>CURLOPT_RETURNTRANSFER：true/false, 设定执行请求时是否返回数据，默认false就是直接输出数据</p>
<p>(详细参数参考php官方网站…..)</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/10/16/javascript 闭包(Closure)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/16/javascript 闭包(Closure)/" itemprop="url">javascript 闭包(Closure)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-16T20:05:00+08:00">
                2015-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闭包是js里的一个难点,很多高级的功能都需要闭包来实现.</p>
<p>下面是我的学习期间的笔记,和个人对闭包的一些理解</p>
<p>说到闭包首先要提到函数的作用域</p>
<p><strong>一、变量的作用域</strong></p>
<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<blockquote>
<p>　　var n=999;</p>
<p>　　function f1 () {<br>　　　　alert(n);<br>　　}</p>
<p>　　f1(); // 999</p>
</blockquote>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<blockquote>
<p>　　function f1(){<br>　　　　var n=999;<br>　　}</p>
<p>　　alert(n); // error</p>
</blockquote>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>
<blockquote>
<p>　　function f1(){<br>　　　　n=999;<br>　　}</p>
<p>　　f1();</p>
<p>　　alert(n); // 999</p>
</blockquote>
<p><strong>二、如何从外部读取局部变量？</strong></p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<blockquote>
<p>　　function f1(){</p>
<p>　　　　var n=999;</p>
<p>　　　　function f2(){<br>　　　　　　alert(n); // 999<br>　　　　}</p>
<p>　　}</p>
</blockquote>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<blockquote>
<p>　　function f1(){</p>
<p>　　　　var n=999;</p>
<p>　　　　function f2(){<br>　　　　　　alert(n);<br>　　　　}</p>
<p>　　　　return f2;</p>
<p>　　}</p>
<p>　　var result=f1();</p>
<p>　　result(); // 999</p>
</blockquote>
<p><strong>三、闭包的概念</strong></p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>
<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p><strong>四、闭包的用途</strong></p>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解这句话呢？请看下面的代码。</p>
<blockquote>
<p>　　function f1(){</p>
<p>　　　　var n=999;</p>
<p>　　　　nAdd=function(){n+=1}</p>
<p>　　　　function f2(){<br>　　　　　　alert(n);<br>　　　　}</p>
<p>　　　　return f2;</p>
<p>　　}</p>
<p>　　var result=f1();</p>
<p>　　result(); // 999</p>
<p>　　nAdd();</p>
<p>　　result(); // 1000</p>
</blockquote>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<p><strong>五、使用闭包的注意点</strong></p>
<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p><strong>六、思考题</strong></p>
<p>如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。</p>
<p>代码片段一。</p>
<blockquote>
<p>　　var name = “The Window”;</p>
<p>　　var object = {<br>　　　　name : “My Object”,</p>
<p>　　　　getNameFunc : function(){<br>　　　　　　return function(){<br>　　　　　　　　return this.name;<br>　　　　　　};</p>
<p>　　　　}</p>
<p>　　};</p>
<p>　　alert(object.getNameFunc()());</p>
</blockquote>
<p>代码片段二。</p>
<blockquote>
<p>　　var name = “The Window”;</p>
<p>　　var object = {<br>　　　　name : “My Object”,</p>
<p>　　　　getNameFunc : function(){<br>　　　　　　var that = this;<br>　　　　　　return function(){<br>　　　　　　　　return that.name;<br>　　　　　　};</p>
<p>　　　　}</p>
<p>　　};</p>
<p>　　alert(object.getNameFunc()());</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/10/07/merge引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/07/merge引擎/" itemprop="url">merge引擎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-07T18:00:00+08:00">
                2015-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/luojianqun/p/4903743.html" target="_blank" rel="noopener">Mysql MERGE引擎简介</a></p>
<p>一. 什么是MERGE<strong>引擎</strong>MERGE存储引擎把一组MyISAM数据表当做一个逻辑单元来对待，让我们可以同时对他们进行查询。</p>
<p><strong>二. 应用场景</strong>如果需要把日志纪录不停的录入MySQL数据库，并且每天、每周或者每个月都创建一个单一的表，而且要时常进行来自多个表的合计查询，MERGE表这时会非常简单有效。</p>
<p><strong>三. 举例</strong>假设有如下两表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 CREATE TABLE `t1` (   </span><br><span class="line">2 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,   </span><br><span class="line">3 `log` varchar(45) ,   </span><br><span class="line">4 PRIMARY KEY (`id`) </span><br><span class="line">5 ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 CREATE TABLE `t2`(   </span><br><span class="line">2 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,   </span><br><span class="line">3 `log` varchar(45) ,   </span><br><span class="line">4 PRIMARY KEY (`id`) </span><br><span class="line">5 ) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<p>假设t1，t2中都有如下记录</p>
<p>+—-+——-+</p>
<p>| id | log |</p>
<p>+—-+——-+</p>
<p>| 1 | test1 |</p>
<p>| 2 | test2 |</p>
<p>| 3 | test3 |</p>
<p>+—-+——-+</p>
<p>建立MERGE表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 CREATE TABLE `t` (   </span><br><span class="line">2 `id` int(10) unsigned NOT NULL AUTO_INCREMENT,   </span><br><span class="line">3 `log` varchar(45) NOT NULL,   </span><br><span class="line">4 PRIMARY KEY (`id`) </span><br><span class="line">5 ) ENGINE=MERGE UNION=(t1, t2) INSERT_METHOD=LAST;</span><br></pre></td></tr></table></figure>
<p>执行select * from t;将会得到如下结果<br>+—-+——-+<br>| id | log |<br>+—-+——-+<br>| 1 | test1 |<br>| 2 | test2 |<br>| 3 | test3 |<br>| 1 | test1 |<br>| 2 | test2 |<br>| 3 | test3|<br>+—-+——-+</p>
<p>从效果上看，t1,t2的记录如同在一张表里一样被罗列了出来。当然，看了这个结果你一定会有一些疑问，在下一节里我们会慢慢解释。现在我们主要来解释一下上面MERGE表的建表语句。<br>1）ENGINE=MERGE<br>指明使用MERGE引擎，有些同学可能见到过ENGINE=MRG_MyISAM的例子，也是对的，它们是一回事。<br>2）UNION=(t1, t2)<br>指明了MERGE表中挂接了些哪表，可以通过alter table的方式修改UNION的值，以实现增删MERGE表子表的功能。<br>3）INSERT_METHOD=LAST<br>INSERT_METHOD指明插入方式，取值可以是：0 不允许插入；FIRST 插入到UNION中的第一个表； LAST 插入到UNION中的最后一个表。<br>4）MERGE表及构成MERGE数据表结构的各成员数据表必须具有完全一样的结构。每一个成员数据表的数据列必须按照同样的顺序定义同样的名字和类型，索引也必须按照同样的顺序和同样的方式定义。<br><strong>四. Cookie问答</strong>1）建表时UNION指明的子表如果存在相同主键的记录会怎么样？<br>相同主键的记录会同时存在于MERGE中，就像第三节中的例子所示。但如果继续向MERGE表中插入数据，若数据主键已存在则无法插入。换言之，MERGE表只对建表之后的操作负责。<br>2）若MREGE后存在重复主键，按主键查询会是什么结果？<br>顺序查询，只出现一条查询记录即停止。比如第三节中的例子，如果执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 select * from t where id=1;</span><br></pre></td></tr></table></figure>
<p>只会得到结果<br>+—-+——–+<br>| id | log |<br>+—-+——–+<br>| 1 | test1 |<br>+—-+——–+</p>
<p>3）直接删除一个子表会出现什么情况，正确删除的方式是怎样的？<br>MERGE表会被破坏，正确方式是用alter table方式先将子表从MERGE表中去除，再删除子表。<br>以第三节中的例子为例，执行如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 alter table t ENGINE=MRG_MyISAM UNION=(t1) INSERT_METHOD=LAST;</span><br></pre></td></tr></table></figure>
<p>可以从MERGE表中去除t2，这里你可以安全的对t2进行任何操作了。</p>
<p>4）误删子表时，如何恢复MERGE表？<br>误删子表时，MERGE表上将无法进行任何操作。<br>方法1，drop MERGE表，重建。重建时注意在UNION部分去掉误删的子表。<br>方法2，建立MERGE表时，会在数据库目录下生成一个.MRG文件，比如设表名为t，则文件名为t.MRG。<br>文件内容类似：<br>t1<br>t2<br>#INSERT_METHOD=LAST<br>指明了MGEGE表的子表构成及插入方式。<br>可以直接修改此文件，去掉误删表的表名。然后执行flush tables即可修复MERGE表。</p>
<p>5）MERGE的子表中之前有记录，且有自增主键，则MERGE表创建后，向其插入记录时主键以什么规则自增？<br>以各表中的AUTO_INCREMENT最大值做为下一次插入记录的主键值。<br>比如t1的自增ID至6，t2至4，则创建MERGE表后，插入的下一条记录ID将会是7</p>
<p>6）两个结构完全相同的但已存在数据的表，是否一定可以合成一个MEREGE表？<br>从实验的结果看，不是这样的，有时创建出的表，无法进行任何操作。<br>所以，推荐的使用方法是先有一个MERGE表，里面只包含一张表，当一个这个表的的大小增长到一定程度（比如200w）时，创建另一张空表，将其挂入MERGE表，然后继续插入记录。</p>
<p>7）删除MERGE表是否会对子表产生影响？<br>不会</p>
<p>8）MREGE表的子表的ENGIN是否有要求？<br>有的，必须是MyISAM表</p>
<p>附:<br>官方给出的关于MERGE表存在的一些问题<br><a href="http://dev.mysql.com/doc/refman/5.1/zh/storage-engines.html#merge-table-problems" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.1/zh/storage-engines.html#merge-table-problems</a><br>如果需要把日志纪录不停的录入MySQL数据库，并且每天、每周或者每个月都创建一个单一的表，而且要时常进行来自多个表的合计查询，MERGE表这时会非常简单有效</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/09/27/Myisam和innodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/27/Myisam和innodb/" itemprop="url">Myisam和innodb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-27T15:10:20+08:00">
                2015-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天来写一点关于数据表的东西把…</p>
<h2 id="Innodb引擎"><a href="#Innodb引擎" class="headerlink" title="Innodb引擎"></a>Innodb引擎</h2><p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库<a href="https://www.2cto.com/os/" target="_blank" rel="noopener">系统</a>，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<h2 id="MyIASM引擎"><a href="#MyIASM引擎" class="headerlink" title="MyIASM引擎"></a>MyIASM引擎</h2><p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<h2 id="两种引擎的选择"><a href="#两种引擎的选择" class="headerlink" title="两种引擎的选择"></a>两种引擎的选择</h2><p>大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。</p>
<h2 id="Index——索引"><a href="#Index——索引" class="headerlink" title="Index——索引"></a>Index——索引</h2><p>索引（Index）是帮助MySQL高效获取数据的数据结构。MyIASM和Innodb都使用了树这种数据结构做为索引，关于树我也曾经写过一篇文章树是一种伟大的数据结构，只是自己的理解，有兴趣的朋友可以去<a href="http://book.2cto.com/" target="_blank" rel="noopener">阅读</a>。下面我接着讲这两种引擎使用的索引结构，讲到这里，首先应该谈一下B-Tree和B+Tree。</p>
<h3 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h3><p>B+Tree是B-Tree的变种，那么我就先讲B-Tree吧，相信大家都知道红黑树，这是我前段时间学《算法》一书时，实现的一颗红黑树，大家可以参考。其实红黑树类似2,3-查找树，这种树既有2叉结点又有3叉结点。B-Tree也与之类似，它的每个结点做多可以有d个分支（叉），d称为B-Tree的度，如下图所示，它的每个结点可以有4个元素，5个分支，于是它的度为5。B-Tree中的元素是有序的，比如图中元素7左边的指针指向的结点中的元素都小于7，而元素7和16之间的指针指向的结点中的元素都处于7和16之间，正是满足这样的关系，才能高效的查找：首先从根节点进行二分查找，找到就返回对应的值，否则就进入相应的区间结点递归的查找，直到找到对应的元素或找到null指针，找到null指针则表示查找失败。这个查找是十分高效的，其时间复杂度为O(logN)（以d为底，当d很大时，树的高度就很低），因为每次检索最多只需要检索树高h个结点。</p>
<p><a href="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000558.png" target="_blank" rel="noopener"><img src="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000558.png" alt="B-Tree"></a></p>
<p>接下来就该讲B+Tree了，它是B-Tree的变种，如下面两张图所示：</p>
<p><a href="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000561.png" target="_blank" rel="noopener"><img src="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000561.png" alt="B+Tree"></a><br><a href="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000665.png" target="_blank" rel="noopener"><img src="https://www.2cto.com/uploadfile/Collfiles/20150327/2015032710000665.png" alt="B+Tree2"></a></p>
<p>从图中就可以看出，B+Tree的内部结点不存储数据，只存储指针，而叶子结点则只存储数据，不存储指针。并且在其每个叶子节点上增加了一个指向湘…�”/database/DB2/“ target=”_blank” class=”keylink”&gt;DB2tK219O92rXjtcTWuNXro6zV4rj208W7r8zhuN/H+Lzkt8POyrXE0NTE3KOsscjI59Tatdq2/tXFzbzW0NKqsunRr7z8zqq00zE4tb00ObXEy/nT0Mr9vt2jrLWx1dK1vTE4uvOjrNa70OjLs9fFvdq147rN1rjV68uz0PKx6cD6vs2/ydLU0ru0ztDUt8POyrW9y/nT0Mr9vt292rXjo6y8q7TzzOG1<a href="https://www.2cto.com/kf/ware/vc/" target="_blank" rel="noopener">vc</a>HLx/i85LLp0a/Qp8LKoaM8L3A+DQo8aDMgaWQ9”myisam引擎的索引结构”&gt;MyISAM引擎的索引结构</p>
<p>MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。</p>
<h3 id="Innodb引擎的索引结构"><a href="#Innodb引擎的索引结构" class="headerlink" title="Innodb引擎的索引结构"></a>Innodb引擎的索引结构</h3><p>MyISAM引擎的索引结构同样也是B+Tree，但是Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是<strong>聚集索引</strong>。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>并且和MyISAM不同，InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/09/20/源码安装Coreseek Makefile.in找不到解决办法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/20/源码安装Coreseek Makefile.in找不到解决办法/" itemprop="url">源码安装Coreseek Makefile.in找不到解决办法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-20T20:15:22+08:00">
                2015-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、出现如下错误：</p>
<p>config.status: creating Makefile<br>config.status: WARNING: ‘Makefile.in’ seems to ignore the –datarootdir setting<br>config.status: error: cannot find input file: src/Makefile.in</p>
<h6 id="通过yum安装autoconf-automake"><a href="#通过yum安装autoconf-automake" class="headerlink" title="通过yum安装autoconf automake"></a>通过yum安装autoconf automake</h6><h6 id="root-linux-mmseg-3-2-14-yum-y-install-autoconf-automake"><a href="#root-linux-mmseg-3-2-14-yum-y-install-autoconf-automake" class="headerlink" title="[root@linux mmseg-3.2.14]# yum -y install autoconf automake"></a>[root@linux mmseg-3.2.14]# yum -y install autoconf automake</h6><h6 id="root-linux-mmseg-3-2-14-aclocal"><a href="#root-linux-mmseg-3-2-14-aclocal" class="headerlink" title="[root@linux mmseg-3.2.14]# aclocal"></a>[root@linux mmseg-3.2.14]# aclocal</h6><h6 id="aclocal-configure-in-26-warning-macro-AM-PROG-LIBTOOL’-not-found-in-library"><a href="#aclocal-configure-in-26-warning-macro-AM-PROG-LIBTOOL’-not-found-in-library" class="headerlink" title="aclocal:configure.in:26: warning: macro AM_PROG_LIBTOOL’ not found in library`"></a>aclocal:configure.in:26: warning: macro AM_PROG_LIBTOOL’ not found in library`</h6><h6 id="root-linux-mmseg-3-2-14-yum-y-install-libtool"><a href="#root-linux-mmseg-3-2-14-yum-y-install-libtool" class="headerlink" title="[root@linux mmseg-3.2.14]# yum -y install libtool`"></a>[root@linux mmseg-3.2.14]# yum -y install libtool`</h6><h6 id="root-linux-mmseg-3-2-14-aclocal-1"><a href="#root-linux-mmseg-3-2-14-aclocal-1" class="headerlink" title="[root@linux mmseg-3.2.14]# aclocal`"></a>[root@linux mmseg-3.2.14]# aclocal`</h6><h6 id="root-linux-mmseg-3-2-14-libtoolize-–forcePutting-files-in-AC-CONFIG-AUX-DIR-config’"><a href="#root-linux-mmseg-3-2-14-libtoolize-–forcePutting-files-in-AC-CONFIG-AUX-DIR-config’" class="headerlink" title="[root@linux mmseg-3.2.14]# libtoolize –forcePutting files in AC_CONFIG_AUX_DIR, `config’."></a>[root@linux mmseg-3.2.14]# libtoolize –forcePutting files in AC_CONFIG_AUX_DIR, `config’.</h6><h6 id="root-linux-mmseg-3-2-14-automake-–add-missing"><a href="#root-linux-mmseg-3-2-14-automake-–add-missing" class="headerlink" title="[root@linux mmseg-3.2.14]# automake –add-missing"></a>[root@linux mmseg-3.2.14]# automake –add-missing</h6><h6 id="root-linux-mmseg-3-2-14-autoconf"><a href="#root-linux-mmseg-3-2-14-autoconf" class="headerlink" title="[root@linux mmseg-3.2.14]# autoconf"></a>[root@linux mmseg-3.2.14]# autoconf</h6><h6 id="root-linux-mmseg-3-2-14-autoheader"><a href="#root-linux-mmseg-3-2-14-autoheader" class="headerlink" title="[root@linux mmseg-3.2.14]# autoheader"></a>[root@linux mmseg-3.2.14]# autoheader</h6><h6 id="root-linux-mmseg-3-2-14-make-clean"><a href="#root-linux-mmseg-3-2-14-make-clean" class="headerlink" title="[root@linux mmseg-3.2.14]# make clean"></a>[root@linux mmseg-3.2.14]# make clean</h6><p>然后重新执行configure命令</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gityuanye.cn/2015/08/30/源码安装apache出错/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lao Yuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/upload/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lao Yuan's Personal Website">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/30/源码安装apache出错/" itemprop="url">源码安装apache出错</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-30T17:11:22+08:00">
                2015-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> 今日编译apache时出错：</p>
<p>#./configure –prefix……检查编辑环境时出现：</p>
<p>checking for APR… no<br>configure: error: APR not found . Please read the documentation</p>
<p>解决办法：</p>
<p>1.下载所需软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/apr/apr-1.4.5.tar.gz  wget http://archive.apache.org/dist/apr/apr-util-1.3.12.tar.gz  wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.10/pcre-8.10.zip</span><br></pre></td></tr></table></figure>
<p>2.编译安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove apr-util-devel apr apr-util-mysql apr-docs apr-devel apr-util apr-util-docs</span><br></pre></td></tr></table></figure>
<p>具体步骤如下:</p>
<p>a:解决apr not found问题&gt;&gt;&gt;&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xt test]# tar -zxf apr-1.4.5.tar.gz  [root@xt test]# cd  apr-1.4.5  [root@xt apr-1.4.5]# ./configure --prefix=/usr/local/apr  [root@xt apr-1.4.5]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>b:解决APR-util not found问题&gt;&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xt test]# tar -zxf apr-util-1.3.12.tar.gz  [root@xt test]# cd apr-util-1.3.12  [root@xt apr-util-1.3.12]# ./configure --prefix=/usr/local/apr-util -with- apr=/usr/local/apr/bin/apr-1-config  [root@xt apr-util-1.3.12]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>c:解决pcre问题&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xt test]#unzip -o pcre-8.10.zip  [root@xt test]#cd pcre-8.10  [root@xt pcre-8.10]#./configure --prefix=/usr/local/pcre  [root@xt pcre-8.10]#make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>4.最后编译Apache时加上：</p>
<p>–with-apr=/usr/local/apr \</p>
<p>–with-apr-util=/usr/local/apr-util/ \</p>
<p>–with-pcre=/usr/local/pcre</p>
<p>成功编译完成~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/upload/image/avatar.jpg"
                alt="Lao Yuan" />
            
              <p class="site-author-name" itemprop="name">Lao Yuan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lao Yuan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
